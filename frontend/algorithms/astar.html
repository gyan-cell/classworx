<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link href="css/style.css" rel="stylesheet">



  <style>
    .generator-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-direction: column;
    }

    .head {
      font-size: 35px;
      text-align: center;
    }

    .output {
      display: flex;
      justify-content: center;
      align-items: center;

      >button {
        margin: 10px;
        align-self: center;
        width: 10rem;
        height: 2rem;
        border-radius: 5px;

        &:hover {
          cursor: pointer;
        }
      }
    }

    .map {
      border: 1px solid black;
      background-color: #ffffff;
      color: #830071
    }

    .settings {
      display: flex;
      flex-flow: row wrap;
      align-items: center;
      justify-content: center;
      align-items: center;
    }

    .color-select {
      display: flex;
      flex-flow: row wrap;
    }

    .color {
      display: flex;
    }

    .swatch {
      width: 24px;
      height: 24px;
      margin: 10px;
      border: 1px solid black;
    }

    .swatch:hover {
      border: 2px solid red;
      margin: 9px;
    }

    .swatch-selected {
      width: 24px;
      height: 24px;
      margin: 9px;
      border: 2px solid blue;
    }

    .color p {
      align-self: center;
    }

    .color #transparent {
      background: linear-gradient(#facdcd, #ff9696)
    }

    .color #orange {
      background-color: rgb(255, 165, 0);
    }

    .color #blue {
      background-color: rgb(0, 0, 255);
    }


    .color #black {
      background-color: black;
    }


    .output {
      display: flex;
      height: 32px;
    }

    .output p {
      align-self: center;
      margin-left: 4px;
      margin-right: 4px;
    }

    .steps {
      margin-left: 4px;
    }

    .path {
      margin-left: 4px;
    }

    .generate-btn {
      height: 24px;
      margin: 10px;
      align-self: center;
    }


    .settings {
      display: flex;
    }

    .parameters {
      margin: 5px;
      display: flex;
      width: 160px;
      flex-flow: row wrap;
    }

    .parameters p {
      margin: 2px;
    }

    #stepDelay {
      width: 100%;
    }

    #tileSlider {
      width: 100%;
    }

    #precSlider {
      width: 100%;
    }

    .cost-calc {
      margin: 5px;
      width: 128px;
    }

    .cost-calc p {
      margin: 2px;
    }

    <style>* {
      margin: 0px;
      padding: 0px;
      box-sizing: border-box;
    }

    .header {
      font-size: 35px;
      text-align: center;
    }

    #array {
      background-color: white;
      height: 305px;
      width: 598px;
      margin: auto;
      position: relative;
      margin-top: 64px;
    }

    .block {
      width: 28px;
      background-color: #6b5b95;
      position: absolute;
      bottom: 0px;
      transition: 0.2s all ease;
    }

    .block_id {
      position: absolute;
      color: black;
      margin-top: -20px;
      width: 100%;
      text-align: center;
    }

    #searchLabel {
      font-size: 20px;
      text-align: center;
      height: 30px;
    }

    #fname {
      width: 50px;
      height: 30px;
      border-radius: 5px;
      font-size: 20px;
      text-align: center;
      margin-left: 5px;
    }

    #btn {
      width: 100px;
      height: 30px;
      border-radius: 5px;
      font-size: 20px;
      text-align: center;
      margin-left: 5px;

      &:hover {
        background-color: #6b5b95;
        color: white;
        cursor: pointer;
      }
    }



    body {
      font-family: monospace;
    }

    header {
      display: flex;
      align-items: center;
      position: relative;
      color: #cee0cf;
      background-color: #436b61;
      width: 100vw;
      height: 20vh;
    }

    header div {
      text-align: center;
      position: relative;
      box-sizing: border-box;
      display: inline-block;
    }

    main {
      user-select: none;
      padding: 20px 0;
    }

    p {
      font-size: 9px;
    }

    h3 {
      font-size: 20px;
    }

    button {
      font-weight: bold;
      font-size: 14px;
      transition: 50ms ease-in-out;
      border: 1px solid #1e2524;
    }

    button:hover {
      transform: scale(1.05);
    }

    .page-logo {
      font-size: 22px;
      line-height: 55px;
      padding: 10px 25px;
      width: 230px;
    }

    .map-size-box * {
      margin: 4px 0;
    }

    .map-size-box {
      font-size: 20px;
    }

    .map-size-box,
    .setup-box,
    .visualize-box {
      margin: 0 20px;
      padding-top: 15px;
      width: 300px;
    }

    .map-size-box input {
      padding-left: 2px;
      width: 36px;
      height: 25px;
    }

    .size-button,
    .visualize-button {
      font-size: 13px;
      letter-spacing: 2px;
      width: 135px;
      height: 30px;
      color: #243f39;
    }

    .node-buttons-box {
      display: flex;
      justify-content: center;
    }

    .node-buttons-box button {
      font-family: monospace;
      letter-spacing: 1px;
      margin: 10px 5px;
      width: 60px;
      height: 50px;
    }

    .block-button {
      color: #cee0cf;
      background-color: #243f39;
    }

    .start-button {
      color: #303b30;
      background-color: #bfeaff;
    }

    .end-button {
      color: #421212;
      background-color: #ff9883;
    }

    .visualize-button {
      width: 180px;
      height: 30px;
      margin-top: 20px;
    }

    .map-legend {
      background-color: #cee0cf;
      height: 5vh;
    }

    .legend-list {
      display: flex;
      justify-content: center;
      align-items: center;
      list-style-type: none;
      height: 100%;
    }

    .legend-list li {
      display: flex;
      align-items: center;
      padding: 0 35px;
    }

    .item-square {
      display: inline-block;
      border: 1px solid black;
      margin-right: 5px;
      width: 20px;
      height: 20px;
    }

    .item-label {
      display: inline-block;
      font-weight: bold;
      color: #252b2a;
      letter-spacing: 1px;
      padding-top: 4px;
      font-size: 15px;
      height: 20px;
    }

    .map-table {
      border-spacing: 0;
      margin: 0 auto;
    }

    .map-table td {
      position: relative;
      text-align: center;
      border: 1px solid black;
      width: 45px;
      height: 45px;
      transition: transform 0.2s ease-out;
    }

    .map-table td:hover {
      z-index: 1;
      transform: scale(1.1);
    }

    .index-label {
      pointer-events: none;
      position: absolute;
      font-size: 10px;
      top: 0%;
      right: 0%;
    }

    .node-color {
      width: 100%;
      height: 100%;
    }
  </style>




</head>

<body>
  <div class="generator-container">
    <div class="head">
      A Star Visualization Algorithm
    </div>
    <canvas class="map" width="512px" height="320px"></canvas>
    <div class="color-select">
      <div class="color">
        <div class="swatch" id="transparent"></div>
        <p>Eraser</p>
      </div>
      <div class="color">
        <div class="swatch" id="orange"></div>
        <p>Start</p>
      </div>
      <div class="color">
        <div class="swatch" id="blue"></div>
        <p>End</p>
      </div>
      <div class="color">
        <div class="swatch" id="black"></div>
        <p>Wall</p>
      </div>
    </div>
  </div>
  <div class="output">
    <button class="generate-btn">Find Path</button>
    <p>Steps: </p>
    <p class="steps">0</p>
    <p>Path Length (tiles): </p>
    <p class="path">0</p>
  </div>
  <div class="settings">
    <div class="parameters">
      <p>Step Delay (ms):</p>
      <p class="delay">100</p>
      <input type="range" min="1" max="3000" value="100" class="slider" id="stepDelay"><br>
      <p>Tile Size (px):</p>
      <p class="tileSize">16</p>
      <input type="range" min="3" max="6" value="4" class="slider" id="tileSlider">
      <p>Precision:</p>
      <p class="precision">1000</p>
      <input type="range" min="0" max="10" value="3" class="slider" id="precSlider">
    </div>
    <div class="cost-calc" id="heuristic">
      <p>Heuristic Distance:</p>
      <input type="radio" id="manhattan" name="heuristic" value="manhattan">
      <label for="manhattan">Manhattan</label><br>
      <input type="radio" id="octile" name="heuristic" value="octile" checked="checked">
      <label for="octile">Octile</label><br>
      <input type="radio" id="euclidean" name="heuristic" value="euclidean">
      <label for="euclidean">Euclidean</label>
    </div>
    <div class="cost-calc" id="fCost">
      <p>fCost Method:</p>
      <input type="radio" id="sum" name="fCost" value="sum" checked="checked">
      <label for="sum">g(n) + h(n)</label><br>
      <input type="radio" id="ignoreG" name="fCost" value="ignoreG">
      <label for="ignoreG">Ignore g(n)</label><br>
    </div>
    <div class="cost-calc" id="tieBreak">
      <p>Tie Breaker:</p>
      <input type="radio" id="cross" name="tiebreak" value="cross" checked="checked">
      <label for="cross">Cross Product</label><br>
      <input type="radio" id="proximity" name="tiebreak" value="proximity">
      <label for="proximity">Proximity</label><br>
      <input type="radio" id="hCost" name="tiebreak" value="hCost">
      <label for="hCost">h(n)</label><br>
      <input type="radio" id="noBreak" name="tiebreak" value="noBreak">
      <label for="noBreak">None</label><br>
    </div>
  </div>

  <body>
    <br />
    <p class="header">Binary Search Tree Visualizer</p>
    <div id="array"></div>
    <br /><br />

    <div style="text-align: center">
      <label id="searchLabel" for="fname">
        Number to be Searched:
      </label>
      <input type="text" id="fname" name="fname" />
      <br /><br />
      <button id="btn" onclick="BinarySearch()">Search</button>
      <br />
      <br />
      <div id="text"></div>
    </div>


    <header>
      <div class="page-logo">
        <h2>Dijkstra's Algorithm</h2>
      </div>
      <div class="map-size-box">
        <h3>Set Map Size</h3>

        <div>
          <label for="width-input">Width</label>
          <input id="width-input" type="number" min="1" max="50" value="10">
        </div>
        <div>
          <label for="height-input">Height</label>
          <input id="height-input" type="number" min="1" max="50" value="5">
        </div>

        <button id="size-button" class="size-button">Resize Map</button>
      </div>
      <div class="setup-box">
        <h3>Setup Nodes</h3>
        <p>(toggle an option and click on the nodes)</p>
        <div class="node-buttons-box">
          <button id="block-button" class="block-button">Block Nodes</button>
          <button id="start-button" class="start-button">Set<br> Start</button>
          <button id="end-button" class="end-button">Set<br> End</button>
          <button id="clear-button" class="clear-button">Clear<br> Map</button>
        </div>
      </div>
      <div class="visualize-box">
        <h3>Start Algorithm</h3>
        <p>(both a start and end node must be placed)</p>

        <button id="visualize-button" class="visualize-button">Visualize Algorithm</button>
      </div>
    </header>

    <div class="map-legend">
      <ul class="legend-list">
        <li>
          <div class="item-square" style="background-color: #ffffff;"></div>
          <div class="item-label">Blank Node</div>
        </li>
        <li>
          <div class="item-square" style="background-color: #243f39;"></div>
          <div class="item-label">Blocked Node</div>
        </li>
        <li>
          <div class="item-square" style="background-color: #fdffbf;"></div>
          <div class="item-label">Visited Node</div>
        </li>
        <li>
          <div class="item-square" style="background-color: #bfeaff;"></div>
          <div class="item-label">Start Node</div>
        </li>
        <li>
          <div class="item-square" style="background-color: #ff9883;"></div>
          <div class="item-label">End Node</div>
        </li>
        <li>
          <div class="item-square" style="background-color: #f6ff70;"></div>
          <div class="item-label">Path Node</div>
        </li>
      </ul>
    </div>

    <main>
      <table id="map-table" class="map-table"></table>
    </main>




    <script>
      var container = document.getElementById("array");

      function generatearray() {

        var arr = [];

        for (var i = 0; i < 20; i++) {
          var val = Number(Math.ceil(Math.random() * 100));
          arr.push(val);
        }

        arr.sort(function (a, b) {
          return a - b;
        });

        for (var i = 0; i < 20; i++) {
          var value = arr[i];

          var array_ele = document.createElement("div");

          array_ele.classList.add("block");

          array_ele.style.height = `${value * 3}px`;
          array_ele.style.transform = `translate(${i * 30}px)`;

          var array_ele_label = document.createElement("label");
          array_ele_label.classList.add("block_id");
          array_ele_label.innerText = value;

          array_ele.appendChild(array_ele_label);
          container.appendChild(array_ele);
        }
      }

      async function BinarySearch(delay = 300) {
        var blocks = document.querySelectorAll(".block");
        var output = document.getElementById("text");

        var num = document.getElementById("fname").value;

        for (var i = 0; i < blocks.length; i += 1) {
          blocks[i].style.backgroundColor = "#6b5b95";
        }

        output.innerText = "";


        var start = 0;
        var end = 19;
        var flag = 0;
        while (start <= end) {
          var mid = Math.floor((start + end) / 2);
          blocks[mid].style.backgroundColor = "#FF4949";

          var value = Number(blocks[mid].childNodes[0].innerHTML);

          await new Promise((resolve) =>
            setTimeout(() => {
              resolve();
            }, delay)
          );

          if (value == num) {
            output.innerText = "Element Found";
            blocks[mid].style.backgroundColor = "#13CE66";
            flag = 1;
            break;
          }
          if (value > num) {
            end = mid - 1;
            blocks[mid].style.backgroundColor = "#6b5b95";
          } else {
            start = mid + 1;
            blocks[mid].style.backgroundColor = "#6b5b95";
          }
        }
        if (flag === 0) {
          output.innerText = "Element Not Found";
        }
      }

      generatearray();

    </script>
  </body>

  <script>
    let onScreenCVS = document.querySelector(".map");
    let onScreenCTX = onScreenCVS.getContext("2d");
    let offScreenCVS = document.createElement('canvas');
    let offScreenCTX = offScreenCVS.getContext("2d");

    let tileSize = 16;
    offScreenCVS.width = 32;
    offScreenCVS.height = 20;

    let img = new Image;
    let source = offScreenCVS.toDataURL();

    onScreenCVS.addEventListener('mousemove', handleMouseMove);
    onScreenCVS.addEventListener('mousedown', handleMouseDown);
    onScreenCVS.addEventListener('mouseup', handleMouseUp);

    let clicked = false;

    function handleMouseMove(e) {
      if (clicked) {
        draw(e)
      }
    }

    function handleMouseDown(e) {
      clicked = true;
      draw(e);
    }

    function handleMouseUp() {
      clicked = false;
    }

    function draw(e) {
      let ratio = onScreenCVS.width / offScreenCVS.width;
      if (offScreenCTX.fillStyle === "rgba(0, 0, 0, 0)") {
        offScreenCTX.clearRect(Math.floor(e.offsetX / ratio), Math.floor(e.offsetY / ratio), 1, 1);
      } else if (offScreenCTX.fillStyle === "#ffa500") {
        let imageData = offScreenCTX.getImageData(0, 0, offScreenCVS.width, offScreenCVS.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          let x = i / 4 % offScreenCVS.width, y = (i / 4 - x) / offScreenCVS.width;
          let color = `rgba(${imageData.data[i]}, ${imageData.data[i + 1]}, ${imageData.data[i + 2]}, ${imageData.data[i + 3]})`
          if (color === "rgba(255, 165, 0, 255)") {
            offScreenCTX.clearRect(x, y, 1, 1);
          }
        }
        offScreenCTX.fillRect(Math.floor(e.offsetX / ratio), Math.floor(e.offsetY / ratio), 1, 1);
      } else if (offScreenCTX.fillStyle === "#0000ff") {
        let imageData = offScreenCTX.getImageData(0, 0, offScreenCVS.width, offScreenCVS.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          let x = i / 4 % offScreenCVS.width, y = (i / 4 - x) / offScreenCVS.width;
          let color = `rgba(${imageData.data[i]}, ${imageData.data[i + 1]}, ${imageData.data[i + 2]}, ${imageData.data[i + 3]})`
          if (color === "rgba(0, 0, 255, 255)") {
            offScreenCTX.clearRect(x, y, 1, 1);
          }
        }
        offScreenCTX.fillRect(Math.floor(e.offsetX / ratio), Math.floor(e.offsetY / ratio), 1, 1);
      } else {
        offScreenCTX.fillRect(Math.floor(e.offsetX / ratio), Math.floor(e.offsetY / ratio), 1, 1);
      }
      source = offScreenCVS.toDataURL();
      renderImage();
    }

    function renderImage() {
      img.onload = () => {
        onScreenCTX.imageSmoothingEnabled = false;
        onScreenCTX.clearRect(0, 0, onScreenCVS.width, onScreenCVS.height);
        onScreenCTX.drawImage(img, 0, 0, onScreenCVS.width, onScreenCVS.height)
        onScreenCTX.fillStyle = "black";
        generateMap();
      }
      img.src = source;
    }

    let palette = document.querySelector('.color-select');

    palette.addEventListener('click', selectColor)

    function selectColor(e) {
      offScreenCTX.fillStyle = e.target.id;
      palette.childNodes.forEach(c => {
        if (c.childNodes[1]) {
          if (c.childNodes[1].id === e.target.id) {
            c.childNodes[1].className = "swatch-selected";
          } else {
            c.childNodes[1].className = "swatch";
          }
        }
      });
    }
    let steps = document.querySelector('.steps');
    let pathLength = document.querySelector('.path');

    let decPlace = 1000;

    let diagonals = true;

    let delaySlider = document.querySelector('#stepDelay');
    let delayDisplay = document.querySelector('.delay');

    delaySlider.addEventListener('input', updateDelay);
    function updateDelay(e) {
      delayDisplay.textContent = delaySlider.value;
    }

    let tileSlider = document.querySelector('#tileSlider');
    let tileSizeDisplay = document.querySelector('.tileSize');

    tileSlider.addEventListener('input', updateTiles);

    function updateTiles(e) {
      tileSize = Math.pow(2, tileSlider.value);
      offScreenCVS.width = onScreenCVS.width / tileSize;
      offScreenCVS.height = onScreenCVS.height / tileSize;
      tileSizeDisplay.textContent = tileSize;
      onScreenCTX.clearRect(0, 0, onScreenCVS.width, onScreenCVS.height)
      offScreenCTX.clearRect(0, 0, offScreenCVS.width, offScreenCVS.height)
      generateMap();
    }

    let precSlider = document.querySelector('#precSlider');
    let precisionDisplay = document.querySelector('.precision');

    precSlider.addEventListener('input', updatePrecision);

    function updatePrecision(e) {
      decPlace = Math.pow(10, precSlider.value);
      precisionDisplay.textContent = decPlace;
    }
    let hButtons = document.querySelector('#heuristic');

    hButtons.addEventListener('input', updateHeuristic);

    function updateHeuristic(e) {
      if (e.target.value === "manhattan") {
        calcHCost = manhattan;
        diagonals = false;
      } else if (e.target.value === "octile") {
        calcHCost = octile;
        diagonals = true;
      } else if (e.target.value === "euclidean") {
        calcHCost = euclid;
        diagonals = true;
      }
    }

    let fButtons = document.querySelector('#fCost');

    fButtons.addEventListener('input', updateFCalc);

    function updateFCalc(e) {
      if (e.target.value === "ignoreG") {
        calcFCost = ignoreG;
      } else if (e.target.value === "sum") {
        calcFCost = sumCost;
      }
    }

    let tieButtons = document.querySelector('#tieBreak');

    tieButtons.addEventListener('input', updateTieBreak);

    function updateTieBreak(e) {
      if (e.target.value === "cross") {
        tieBreak = crossBreak;
        compareFCost = naiveRank;
      } else if (e.target.value === "proximity") {
        tieBreak = proximBreak;
        compareFCost = naiveRank;
      } else if (e.target.value === "hCost") {
        tieBreak = noBreak;
        compareFCost = deferToH;
      } else if (e.target.value === "noBreak") {
        tieBreak = noBreak;
        compareFCost = naiveRank;
      }
    }
    let calcGCost = calcPath;
    function calcPath(node) {
      let curr = node;
      let cost = 0;
      while (curr.parent) {
        let step = Math.floor(euclid(curr, curr.parent) * decPlace) / decPlace;
        cost += step;
        curr = curr.parent;
      }
      cost = Math.floor(cost * decPlace) / decPlace;
      return cost;
    }
    let calcHCost = octile;
    function manhattan(node1, node2) {
      let a = Math.abs(node1.x - node2.x);
      let b = Math.abs(node1.y - node2.y);
      return a + b;
    }
    function octile(node1, node2) {
      let a = Math.abs(node1.x - node2.x);
      let b = Math.abs(node1.y - node2.y);
      function leastSide() {
        if (a > b) {return b;} else {return a;}
      }
      let diagonalCost = leastSide() * Math.sqrt(2);
      let horizontalCost = Math.abs(b - a);
      let sum = diagonalCost + horizontalCost;
      return Math.floor(sum * decPlace) / decPlace;
    }
    function euclid(node1, node2) {
      let distance = Math.hypot(node1.x - node2.x, node1.y - node2.y);
      return Math.floor(distance * decPlace) / decPlace;
    }
    let tieBreak = crossBreak;
    function crossBreak(node) {
      let dx1 = node.x - end.x;
      let dy1 = node.y - end.y;
      let dx2 = start.x - end.x;
      let dy2 = start.y - end.y;
      let cross = Math.abs(dx1 * dy2 - dx2 * dy1);
      let breaker = cross * (1 / decPlace)
      return breaker;
    }
    function proximBreak(node) {
      let breaker = euclid(node, end) * (1 / decPlace);
      return breaker;
    }
    function noBreak(node) {
      return 0;
    }
    let calcFCost = sumCost;
    function sumCost(g, h) {
      return Math.floor((g + h) * decPlace) / decPlace;
    }
    function ignoreG(g, h) {
      return h;
    }
    let compareFCost = deferToH;
    function deferToH(obj1, obj2) {
      if (obj1.fCost === obj2.fCost) {
        if (obj1.hCost > obj2.hCost) {
          return 1;
        } else {
          return -1;
        }
      } else if (obj1.fCost > obj2.fCost) {
        return 1;
      } else if (obj1.fCost < obj2.fCost) {
        return -1;
      }
      return 0;
    }
    function naiveRank(obj1, obj2) {
      if (obj1.fCost > obj2.fCost) {
        return 1;
      } else if (obj1.fCost < obj2.fCost) {
        return -1;
      }
      return 0;
    }
    let gameGrid = [];
    let start = {};
    let end = {};
    let walls = [];

    function generateMap(e) {
      gameGrid = [];
      start = {};
      end = {};
      let imageData = offScreenCTX.getImageData(0, 0, offScreenCVS.width, offScreenCVS.height);
      for (let i = 0; i < offScreenCVS.height; i++) {
        gameGrid[i] = [];
        for (let j = 0; j < offScreenCVS.width; j++) {
          gameGrid[i][j] = {parent: null, type: "free", x: j, y: i, gCost: 0, hCost: 0, fCost: 0}
          onScreenCTX.beginPath();
          onScreenCTX.rect(j * tileSize, i * tileSize, tileSize, tileSize);
          onScreenCTX.stroke();
        }
      }
      walls = [];
      for (let i = 0; i < imageData.data.length; i += 4) {
        let x = i / 4 % offScreenCVS.width, y = (i / 4 - x) / offScreenCVS.width;
        let color = `rgba(${imageData.data[i]}, ${imageData.data[i + 1]}, ${imageData.data[i + 2]}, ${imageData.data[i + 3]})`
        switch (color) {
          case "rgba(0, 0, 0, 255)":
            gameGrid[y][x].type = "wall";
            walls.push(gameGrid[y][x])
            break;
          case "rgba(255, 165, 0, 255)":
            gameGrid[y][x].type = "start";
            start = gameGrid[y][x];
            break;
          case "rgba(0, 0, 255, 255)":
            gameGrid[y][x].type = "end";
            end = gameGrid[y][x];
            break;
          default:
        }
      }
    }

    function findPath() {
      let open = new Set();
      open.add(start);
      start.gCost = 0;
      start.hCost = Math.floor((calcHCost(start, end) + tieBreak(start)) * decPlace) / decPlace;
      start.fCost = calcFCost(start.gCost, start.hCost);
      let closed = new Set();
      let current = start;

      function drawPath(path, delay) {
        let pathIndex = 0;
        function recursor() {
          let tile = path[pathIndex]
          onScreenCTX.fillStyle = "rgb(204,204,255)"
          onScreenCTX.fillRect(tile.x * tileSize + 1, tile.y * tileSize + 1, tileSize - 2, tileSize - 2)
          if (pathIndex === 0) {
            onScreenCTX.fillStyle = "rgb(255,248,43)"
            onScreenCTX.fillRect(tile.x * tileSize + 1, tile.y * tileSize + 1, tileSize - 2, tileSize - 2)
          }
          if (pathIndex === path.length - 1) {
            onScreenCTX.fillStyle = "rgb(97,92,255)"
            onScreenCTX.fillRect(tile.x * tileSize + 1, tile.y * tileSize + 1, tileSize - 2, tileSize - 2)
          }
          pathIndex += 1;
          if (pathIndex < path.length) {setTimeout(recursor, delay)}
        }
        recursor();
      }
      function drawTempPath(path) {
        let pathIndex = 0;
        function recursor() {
          let tile = path[pathIndex]
          onScreenCTX.fillStyle = "rgba(229, 124, 255, 255)"
          onScreenCTX.fillRect(tile.x * tileSize + 1, tile.y * tileSize + 1, tileSize - 2, tileSize - 2)
          pathIndex += 1;
          if (pathIndex < path.length) {recursor()}
        }
        recursor();
      }
      let stepCount = 0;
      steps.textContent = 0;
      pathLength.textContent = 0;
      recursiveLoop();
      function recursiveLoop() {
        stepCount += 1;
        steps.textContent = stepCount;
        pathLength.textContent = current.gCost;
        onScreenCTX.clearRect(0, 0, 512, 320)
        for (let i = 0; i < offScreenCVS.height; i++) {
          for (let j = 0; j < offScreenCVS.width; j++) {
            onScreenCTX.beginPath();
            onScreenCTX.rect(j * tileSize, i * tileSize, tileSize, tileSize);
            onScreenCTX.stroke();
          }
        }
        walls.forEach(w => {
          onScreenCTX.fillStyle = "black";
          onScreenCTX.fillRect(w.x * tileSize + 1, w.y * tileSize + 1, tileSize - 2, tileSize - 2);
        })
        open.forEach(n => {
          onScreenCTX.fillStyle = "rgb(33,181,235)";
          onScreenCTX.fillRect(n.x * tileSize + 1, n.y * tileSize + 1, tileSize - 2, tileSize - 2);
          onScreenCTX.fillStyle = "black";
          onScreenCTX.font = `${tileSize / 3}px Arial`;
          onScreenCTX.fillText(n.fCost, n.x * tileSize, n.y * tileSize + (tileSize / 2));
        });
        closed.forEach(n => {
          onScreenCTX.fillStyle = `rgba(222,0,0,${n.hCost / n.fCost})`;
          onScreenCTX.fillRect(n.x * tileSize + 1, n.y * tileSize + 1, tileSize - 2, tileSize - 2);
          onScreenCTX.fillStyle = `rgba(83,222,2,${n.gCost / n.fCost})`;
          onScreenCTX.fillRect(n.x * tileSize + 1, n.y * tileSize + 1, tileSize - 2, tileSize - 2);
        })
        function progressPath() {
          let curr = current;
          let tempPath = [];
          while (curr.parent) {
            tempPath.push(curr);
            curr = curr.parent;
          }
          if (tempPath.length > 1) {drawTempPath(tempPath.reverse())};
        }
        progressPath()
        onScreenCTX.fillStyle = "orange";
        onScreenCTX.fillRect(start.x * tileSize + 1, start.y * tileSize + 1, tileSize - 2, tileSize - 2);
        onScreenCTX.fillStyle = "blue";
        onScreenCTX.fillRect(end.x * tileSize + 1, end.y * tileSize + 1, tileSize - 2, tileSize - 2);
        onScreenCTX.fillStyle = "purple";
        onScreenCTX.fillRect(current.x * tileSize + 1, current.y * tileSize + 1, tileSize - 2, tileSize - 2);
        onScreenCTX.fillStyle = "black";
        onScreenCTX.fillText(current.fCost, current.x * tileSize, current.y * tileSize + (tileSize / 2));
        open.delete(current);
        closed.add(current);
        if (current === end) {
          let curr = current;
          let tempPath = [];
          while (curr.parent) {
            tempPath.push(curr);
            curr = curr.parent;
          }
          tempPath.push(curr);
          let truePath = tempPath.reverse();
          drawPath(truePath, delaySlider.value);
          return truePath;
        }
        let neighbors = [];
        let east, west, south, north, northeast, northwest, southeast, southwest;
        if (gameGrid[current.y][current.x + 1]) {
          east = gameGrid[current.y][current.x + 1];
          neighbors.push(east);
        }
        if (gameGrid[current.y][current.x - 1]) {
          west = gameGrid[current.y][current.x - 1];
          neighbors.push(west);
        }
        if (gameGrid[current.y + 1]) {
          south = gameGrid[current.y + 1][current.x];
          neighbors.push(south);
          if (diagonals) {
            if (gameGrid[current.y + 1][current.x - 1]) {
              southwest = gameGrid[current.y + 1][current.x - 1];
              neighbors.push(southwest);
            }
            if (gameGrid[current.y + 1][current.x + 1]) {
              southeast = gameGrid[current.y + 1][current.x + 1];
              neighbors.push(southeast);
            }
          }
        }
        if (gameGrid[current.y - 1]) {
          north = gameGrid[current.y - 1][current.x];
          neighbors.push(north);
          if (diagonals) {
            if (gameGrid[current.y - 1][current.x - 1]) {
              northwest = gameGrid[current.y - 1][current.x - 1];
              neighbors.push(northwest);
            }
            if (gameGrid[current.y - 1][current.x + 1]) {
              northeast = gameGrid[current.y - 1][current.x + 1];
              neighbors.push(northeast);
            }
          }
        }

        for (let i = 0; i < neighbors.length; i++) {
          let neighbor = neighbors[i];
          if (neighbor.type === "wall" || closed.has(neighbor)) {
            continue;
          }
          if (neighbor === northeast) {
            if ((north.type === "wall") && (east.type === "wall")) {
              continue;
            }
          }
          if (neighbor === northwest) {
            if ((north.type === "wall") && (west.type === "wall")) {
              continue;
            }
          }
          if (neighbor === southeast) {
            if ((south.type === "wall") && (east.type === "wall")) {
              continue;
            }
          }
          if (neighbor === southwest) {
            if ((south.type === "wall") && (west.type === "wall")) {
              continue;
            }
          }
          let tCost = euclid(neighbor, current);
          if (!(open.has(neighbor) || closed.has(neighbor))) {
            if (neighbor != start) {neighbor.parent = current;}
            open.add(neighbor);
            neighbor.gCost = calcGCost(neighbor);
            neighbor.hCost = Math.floor((calcHCost(neighbor, end) + tieBreak(neighbor)) * decPlace) / decPlace;
            neighbor.fCost = calcFCost(neighbor.gCost, neighbor.hCost);
          } else if (open.has(neighbor) && neighbor.gCost > current.gCost + tCost) {
            if (neighbor != start) {neighbor.parent = current;}
            neighbor.gCost = calcGCost(neighbor);
            neighbor.fCost = calcFCost(neighbor.gCost, neighbor.hCost);
          }
        }
        let arr = [...open]
        arr.sort(compareFCost)
        current = arr[0]
        if (open.size > 0) {setTimeout(recursiveLoop, delaySlider.value)};
      }
    }
    let generateBtn = document.querySelector(".generate-btn")

    generateBtn.addEventListener("click", makePath);

    generateMap();

    function makePath() {
      findPath();
    }


    const mapTable = document.getElementById('map-table')
    const nodeColors = ['#ffffff', '#243f39', '#fdffbf', '#bfeaff', '#ff9883', '#f6ff70']

    class node {
      constructor(distance, parent, isVisited, isBlocked, colorIndex) {
        this.distance = distance
        this.parent = parent
        this.isVisited = isVisited
        this.isBlocked = isBlocked
        this.colorIndex = colorIndex
      }
    }

    function createMapObject(width, height) {
      let mapWidth = width
      let mapHeight = height
      let mapSize = mapWidth * mapHeight
      let myNodes = []

      let mapNodeAmmount = mapSize
      for (let i = 0; i < mapNodeAmmount; i++) {
        myNodes.push(new node(Infinity, undefined, false, false, 0))
      }

      function render() {
        let html = ''

        for (let row = 0; row < mapHeight; row++) {
          html += '<tr>'

          for (let column = 0; column < mapWidth; column++) {
            nodeIndex = column + (row * mapWidth)
            let colorIndex = myNodes[nodeIndex].colorIndex

            html += `<td style="background-color:${nodeColors[colorIndex]};"></td>`
          }

          html += '</tr>'
        }

        mapTable.innerHTML = html
      }

      return {
        render,
        nodes: myNodes,
        width: mapWidth,
        height: mapHeight,
        size: mapSize
      }
    }

    function createDijkstraObject(nodeMap, startNode, endNode) {
      let nodes = nodeMap.nodes
      let unvisitedNodes = [startNode]
      let currentNode
      startNode.distance = 0

      function doStep() {
        currentNode = chooseBestNode()
        visitNode(currentNode)

        return currentNode
      }

      function visitNode(nodeToVisit) {
        let nodeToVisitIndex = nodes.indexOf(nodeToVisit)
        let nodeNeighbours = getUnvisitedNeighbours(nodeToVisitIndex)
        let tentativeDistance = nodeToVisit.distance + 1

        if (nodeNeighbours.length > 0) {
          for (let neighbour of nodeNeighbours) {
            if (neighbour.distance > tentativeDistance) {
              neighbour.distance = tentativeDistance
              neighbour.parent = nodeToVisit
              unvisitedNodes.push(neighbour)
            }
          }
        }

        let visitedIndex = unvisitedNodes.indexOf(nodeToVisit)
        unvisitedNodes.splice(visitedIndex, 1)
        nodeToVisit.isVisited = true
      }

      function chooseBestNode() {
        let bestNode = unvisitedNodes[0]

        for (let unvisitedNode of unvisitedNodes) {
          if (unvisitedNode.distance < bestNode.distance) {
            bestNode = unvisitedNode
          }
        }

        return bestNode
      }

      function getUnvisitedNeighbours(nodeIndex) {
        let neighbours = []
        let unvisitedNeighbours = []

        if (nodeIndex > nodeMap.width) {
          neighbours.push(nodes[nodeIndex - nodeMap.width])
        }

        if (nodeIndex + nodeMap.width < nodeMap.size) {
          neighbours.push(nodes[nodeIndex + nodeMap.width])
        }

        if ((nodeIndex + 1) % nodeMap.width !== 0) {
          neighbours.push(nodes[nodeIndex + 1])
        }

        if (nodeIndex % nodeMap.width !== 0) {
          neighbours.push(nodes[nodeIndex - 1])
        }

        for (let neighbour of neighbours) {
          if (!neighbour.isVisited && !neighbour.isBlocked) {
            unvisitedNeighbours.push(neighbour)
          }
        }

        return unvisitedNeighbours
      }

      function checkIfDone() {
        return (unvisitedNodes.includes(endNode)) ? true : false
      }

      function tracePath(nodeToTrace) {
        pathNodes = []

        let pathHead = nodeToTrace
        while (pathHead.parent !== startNode) {
          pathHead = pathHead.parent
          pathNodes.push(pathHead)
        }

        return pathNodes
      }

      return {
        doStep,
        checkIfDone,
        tracePath,
        getUnvisitedNeighbours,
        nodes,
        unvisitedNodes,
        startNode,
        endNode
      }
    }


    const sizeButton = document.getElementById('size-button')
    const widthInput = document.getElementById('width-input')
    const heightInput = document.getElementById('height-input')
    const blockButton = document.getElementById('block-button')
    const startButton = document.getElementById('start-button')
    const endButton = document.getElementById('end-button')
    const clearButton = document.getElementById('clear-button')
    const visualizeButton = document.getElementById('visualize-button')
    mapTable.addEventListener('click', doCurrentFuctionOnNode)
    sizeButton.addEventListener('click', setMapSize)
    blockButton.addEventListener('click', function () {currentFunction = blockNode})
    startButton.addEventListener('click', function () {currentFunction = setStartNode})
    endButton.addEventListener('click', function () {currentFunction = setEndNode})
    clearButton.addEventListener('click', clearMap)
    visualizeButton.addEventListener('click', visualizeAlgorithm)

    let myMap = createMapObject(15, 10)
    let startingNode
    let endingNode
    let isRunning = false
    let currentFunction = function () { }


    function setMapSize() {
      myMap = createMapObject(+widthInput.value, +heightInput.value)
      myMap.render()
      startingNode = undefined
      endingNode = undefined
    }

    function clearMap() {
      myMap = createMapObject(myMap.width, myMap.height)
      myMap.render()
      startingNode = undefined
      endingNode = undefined
    }

    function doCurrentFuctionOnNode() {
      tdClicked = event.target
      if (tdClicked.tagName === 'TD') {
        let tdRowIndex = tdClicked.parentElement.rowIndex
        let tdIndex = tdClicked.cellIndex + (tdRowIndex * myMap.width)
        let clickedNode = myMap.nodes[tdIndex]

        currentFunction(clickedNode)
      }
    }

    function blockNode(blockedNode) {
      if (blockedNode === startingNode || blockedNode === endingNode) {
        return
      }
      if (blockedNode.isBlocked) {
        blockedNode.isBlocked = false
        blockedNode.colorIndex = 0
      } else {
        blockedNode.isBlocked = true
        blockedNode.colorIndex = 1
      }

      myMap.render()
    }

    function setStartNode(newStartNode) {
      if (newStartNode === endingNode) {
        return
      }
      if (startingNode !== undefined) {
        startingNode.colorIndex = 0
      }
      startingNode = newStartNode
      startingNode.colorIndex = 3
      startingNode.isBlocked = false

      myMap.render()
    }

    function setEndNode(newEndNode) {
      if (newEndNode === startingNode) {
        return
      }
      if (endingNode !== undefined) {
        endingNode.colorIndex = 0
      }
      endingNode = newEndNode
      endingNode.colorIndex = 4
      endingNode.isBlocked = false

      myMap.render()
    }

    function visualizeAlgorithm() {
      if (startingNode === undefined || endingNode === undefined) {
        return
      }

      mapTable.style.pointerEvents = 'none'
      visualizeButton.innerHTML = 'Stop Algorithm'
      visualizeButton.removeEventListener('click', visualizeAlgorithm)
      visualizeButton.addEventListener('click', stopAlgorithm)
      isRunning = true

      let myDijkstra = new createDijkstraObject(myMap, startingNode, endingNode)

      startAlgorithm(myDijkstra, 100)
    }

    function startAlgorithm(algorithm, speed) {
      let nodeToAnimate = algorithm.doStep()

      if (!isRunning) {
        return
      }

      if (nodeToAnimate !== algorithm.startNode) {
        nodeToAnimate.colorIndex = 2
      }

      if (algorithm.checkIfDone()) {
        let path = algorithm.tracePath(algorithm.endNode)

        for (pathNode of path) {
          pathNode.colorIndex = 5
        }

        stopAlgorithm()
        return
      }

      if (algorithm.unvisitedNodes.length > 0) {
        return setTimeout(function () {
          startAlgorithm(algorithm, speed)
          myMap.render()
        }, speed)
      }
      stopAlgorithm()
    }

    function stopAlgorithm() {
      visualizeButton.innerHTML = 'Reset Map'
      visualizeButton.removeEventListener('click', stopAlgorithm)
      visualizeButton.addEventListener('click', resetMap)
      mapTable.style.pointerEvents = 'all'
      isRunning = false
    }

    function resetMap() {
      visualizeButton.innerHTML = 'Visualize Algorithm'
      visualizeButton.removeEventListener('click', resetMap)
      visualizeButton.addEventListener('click', visualizeAlgorithm)

      for (let i = 0; i < myMap.nodes.length; i++) {
        let nodeToReset = myMap.nodes[i]
        nodeToReset.distance = Infinity
        nodeToReset.parent = undefined
        nodeToReset.isVisited = false
        if (nodeToReset !== startingNode && nodeToReset !== endingNode && !nodeToReset.isBlocked) {
          nodeToReset.colorIndex = 0
        }
      }

      myMap.render()
    }

    myMap.render()


  </script>
</body>

</html>
